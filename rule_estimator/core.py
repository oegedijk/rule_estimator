# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['BusinessRule', 
           'CaseWhen',
           'BinaryDecisionNode',
           'RuleEstimator',
           'RuleClassifier', 
           'RuleRegressor']

from typing import Union, List, Dict, Tuple
from pathlib import Path

import numpy as np
import pandas as pd

from sklearn.base import BaseEstimator
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.metrics import accuracy_score, precision_score, recall_score, mean_squared_error

from igraph import Graph

from .storable import Storable


def describe_businessrule(obj, spaces:int=0)->str:
    """If obj has a __rulerepr__ method then adds it to a string,
    and then recursively finds all attributes with __rulerepr__ methods
    and adds them to the string with appropriate indentation.

    Args:
        obj (BusinessRule): BusinessRule instance to be recursively described.

        spaces (int, optional): Number of spaces of indentation. Gets recursively
            increased. Defaults to 0.

    Returns:
        str: description of the entire tree of businessrules inside obj.
    """
    rulerepr = ""
    if isinstance(obj, BusinessRule):
        rule_id = f"{obj._rule_id}: " if obj._rule_id is not None else ""
        rulerepr += " " * spaces + rule_id + obj.__rulerepr__() # + "\n"
        if hasattr(obj, "default") and not np.isnan(obj.default):
            rulerepr += f" (default={obj.default})\n"
        else:
            rulerepr += "\n"
    if hasattr(obj, "__dict__"):
        for k, v in obj.__dict__.items():
            if not k.startswith("_"):
                rulerepr += describe_businessrule(v, spaces=spaces+2)
    elif isinstance(obj, dict):
        for v in obj.values():
            rulerepr += describe_businessrule(v, spaces=spaces+2)
    elif isinstance(obj, list):
        for v in obj:
            rulerepr += describe_businessrule(v, spaces=spaces+1)
    return rulerepr


class BusinessRule(BaseEstimator, Storable):
    def __init__(self, prediction=None, default=None):
        self._store_child_params(level=2)
        if not hasattr(self, "prediction"):
            self.prediction = prediction
        if not hasattr(self, "default"):
            self.default = default
            
        if self.prediction is None:
            self.prediction = np.nan
        if self.default is None:
            self.default = np.nan
            
        self._rule_id = None
        
    def fit(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None):
        pass

    def predict(self, X:pd.DataFrame)->np.ndarray:
        assert hasattr(self, "__rule__"), "You need to implement the __rule__ method first!"
        return np.where(self.__rule__(X), self.prediction, self.default)
    
    def _score_rule(self, y, y_preds, mask, prediction, default, 
                    scores_df=None, is_classifier=False)->pd.DataFrame:
        if scores_df is None:
            scores_df = pd.DataFrame(columns=[
                'rule_id', 'name','description', 'prediction', 
                'n_inputs', 'n_outputs','coverage', 
                'accuracy' if is_classifier else 'rmse'
            ])
        score_dict = dict(
                rule_id=self._rule_id, name=self.__class__.__name__,
                description=self.__rulerepr__(),
                prediction = prediction,
                n_inputs=len(y), n_outputs=mask.sum(), 
                coverage = mask.mean() if len(mask)>0 else np.nan,
        )
        
        if is_classifier:
            if len(y[mask]) > 0:
                score_dict['accuracy'] = accuracy_score(y[mask], y_preds[mask])
            else:
                score_dict['accuracy'] = np.nan
        else:
            if len(y[mask]) > 0:
                score_dict['rmse'] = mean_squared_error(y[mask], y_preds[mask], squared=False)
            else:
                score_dict['rmse'] = np.nan
        
        scores_df = scores_df.append(score_dict, ignore_index=True)
        
        if not np.isnan(default):
            default_score_dict = dict(
                    rule_id=self._rule_id, 
                    name=chr(int("21B3", 16)), #self.__class__.__name__,
                    description=f"default: predict {self.default}",
                    prediction=default,
                    n_inputs=len(y), n_outputs=np.invert(mask).sum(), 
                    coverage = np.invert(mask).mean() if len(mask)>0 else np.nan,       
            )
            if is_classifier:
                if np.invert(mask).sum() > 0:
                    default_score_dict['accuracy'] = accuracy_score(
                        y[~mask], np.full(np.invert(mask).sum(), default))
                else:
                    default_score_dict['accuracy'] = np.nan      
            else:
                if np.invert(mask).sum() > 0:
                    default_score_dict['rmse'] = mean_squared_error(
                        y[~mask], np.full(np.invert(mask).sum(), default), squared=False)
                else:
                    default_score_dict['rmse'] = np.nan
                    
            scores_df = scores_df.append(default_score_dict, ignore_index=True)
        return scores_df
    
    def score_rule(self, X:pd.DataFrame, y:Union[np.ndarray, pd.Series], 
                   scores_df:pd.DataFrame=None, is_classifier:bool=False)->pd.DataFrame:
        mask = pd.Series(self.__rule__(X)).values
        y_preds = self.predict(X)
        return self._score_rule(y, y_preds, mask, 
                                self.prediction, self.default, 
                                scores_df, is_classifier)
    
    def set_rule_id(self, rule_id:int=0)->int:
        self._rule_id = rule_id
        return rule_id+1
    
    def get_max_rule_id(self, max_rule_id:int=0)->int:
        if self._rule_id is not None and self._rule_id > max_rule_id:
            return self._rule_id
        return max_rule_id
    
    def get_rule(self, rule_id:int):
        if self._rule_id is not None and self._rule_id == rule_id:
            return self
        
    def replace_rule(self, rule_id:int, new_rule)->None:
        assert isinstance(new_rule, BusinessRule)
        if self._rule_id is not None and self._rule_id == rule_id:
            self.__class__ = new_rule.__class__
            self.__dict__.update(new_rule.__dict__)
            
    def get_rule_params(self, rule_id:int)->dict:
        if self._rule_id is not None and self._rule_id == rule_id:
            return self.get_params()
    
    def set_rule_params(self, rule_id:int, **params)->None:
        if self._rule_id is not None and self._rule_id == rule_id:
            self.set_params(**params)
          
    def get_rule_input(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                      )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if self._rule_id is not None and self._rule_id == rule_id:
            if y is not None:
                return X, y
            else:
                return X
            
        if y is not None:
            return None, None
        else:
            return None
        
    def get_rule_leftover(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                         )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if self._rule_id is not None and self._rule_id == rule_id:
            mask = np.invert(pd.Series(self.__rule__(X)).values)
            if y is not None:
                return X[mask], y[mask]
            else:
                return X[mask]
            
        if y is not None:
            return None, None
        else:
            return None
                    
    def get_params(self, deep:bool=True)->dict:
        """ """
        return self._stored_params

    def set_params(self, **params)->None:
        """ """
        for k, v in params.items():
            if k in self._stored_params:
                self._stored_params[k] = v
                setattr(self, k, v)
                
    def add_to_igraph(self, graph:Graph=None)->Graph:
        if graph is None:
            graph = Graph()
            graph.vs.set_attribute_values('rule_id', [])
            graph.vs.set_attribute_values('name', [])
            graph.vs.set_attribute_values('description', [])
            graph.vs.set_attribute_values('rule', [])
        graph.add_vertex(
            rule_id=self._rule_id,
            name=self.__class__.__name__,
            description=self.__rulerepr__(),
            rule=self
        )
        return graph
        
    def __rulerepr__(self)->str:
        return "BusinessRule"

    def describe(self)->str:
        return describe_businessrule(self)

    def to_yaml(self, filepath:Union[Path, str]=None, return_dict:bool=False):
        """Store object to a yaml format.

        Args:
            filepath: file where to store the .yaml file. If None then just return the
                yaml as a str.
            return_dict: instead of return a yaml str, return the raw dict.

        """
        return super().to_yaml(filepath, return_dict, comment=self.describe())


class CaseWhen(BusinessRule):
    def __init__(self, rules:List[BusinessRule], default=None):
        super().__init__()
        if not isinstance(self.rules, list):
            self.rules = [self.rules]

    def append_rule(self, new_rule:BusinessRule)->None:
        self.rules.append(new_rule)
        
    def predict(self, X:pd.DataFrame)->np.ndarray:
        y = np.full(len(X), np.nan)
        for rule in self.rules:
            y[np.isnan(y)] = rule.predict(X[np.isnan(y)])
            
        if not np.isnan(self.default):
            y = np.where(np.isnan(y), self.default, y)
        return y
      
    def score_rule(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray], 
                   scores_df:pd.DataFrame=None, is_classifier:bool=False)->pd.DataFrame:
        
        # first predict without filling in the default
        if not np.isnan(self.default):
            old_default = self.default
            self.default = np.nan
            y_preds = self.predict(X)
            self.default = old_default 
        else:
            y_preds = self.predict(X)
            
        mask = np.invert(np.isnan(y_preds))
        scores_df = self._score_rule(y, y_preds, mask,
                                     prediction=np.nan, default=self.default, 
                                     scores_df=scores_df, is_classifier=is_classifier)
  
        y_temp = np.full(len(X), np.nan)
        for rule in self.rules:
            scores_df = rule.score_rule(X[np.isnan(y_temp)], y[np.isnan(y_temp)], scores_df, is_classifier)
            y_temp[np.isnan(y_temp)] = rule.predict(X[np.isnan(y_temp)])
            
        return scores_df
    
    def set_rule_id(self, rule_id:int=0)->int:
        rule_id = super().set_rule_id(rule_id)
        for rule in self.rules:
            rule_id = rule.set_rule_id(rule_id) 
        return rule_id
    
    def get_max_rule_id(self, max_rule_id:int=0)->int:
        max_rule_id = super().get_max_rule_id(max_rule_id)
        
        for rule in self.rules:
            max_rule_id = rule.get_max_rule_id(max_rule_id)
        return max_rule_id
    
    def get_rule(self, rule_id:int)->BusinessRule:
        if self._rule_id is not None and self._rule_id == rule_id:
            return self
        
        for rule in self.rules:
            return_rule = rule.get_rule(rule_id)
            if return_rule is not None:
                return return_rule
    
    def get_rule_input(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                      )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if y is not None:
            input_X, input_y = super().get_rule_input(rule_id, X, y)
            if input_X is not None:
                return input_X, input_y
        else:
            input_X = super().get_rule_input(rule_id, X)
            if input_X is not None:
                return input_X
            
            
        y_temp = np.full(len(X), np.nan)
        for rule in self.rules:
            mask = np.isnan(y_temp)
            if y is not None:
                input_X, input_y = rule.get_rule_input(rule_id, X[mask], y[mask])
                if input_X is not None:
                    return input_X, input_y
            else:
                input_X = rule.get_rule_input(rule_id, X[mask])
                if input_X is not None:
                    return input_X
            y_temp[mask] = rule.predict(X[mask])     
        
        if y is not None:
            return None, None
        else:
            return None
        
    def get_rule_leftover(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                         )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if self._rule_id is not None and self._rule_id == rule_id:
            # first predict without filling in the default to get the mask
            old_default = self.default
            self.default = np.nan
            y_preds = self.predict(X)
            self.default = old_default 
            mask = np.isnan(y_preds)
            if y is not None:
                return X[mask], y[mask]
            else:
                return X[mask]
            
        y_temp = np.full(len(X), np.nan)
        for rule in self.rules:
            mask = np.isnan(y_temp)
            if y is not None:
                leftover_X, leftover_y = rule.get_rule_leftover(rule_id, X[mask], y[mask])
                if leftover_X is not None:
                    return leftover_X, leftover_y
            else:
                leftover_X = rule.get_rule_leftover(rule_id, X[mask])
                if leftover_X is not None:
                    return leftover_X
            y_temp[mask] = rule.predict(X[mask])   
            
        if y is not None:
            return None, None
        else:
            return None
        
    def replace_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        super().replace_rule(rule_id, new_rule)
        
        for rule in self.rules:
            rule.replace_rule(rule_id, new_rule)
            
    def get_rule_params(self, rule_id:int)->dict:
        if self._rule_id is not None and self._rule_id == rule_id:
            return self.get_params()

        for rule in self.rules:
            params = rule.get_rule_params(rule_id)
            if params is not None: 
                return params
            
    def set_rule_params(self, rule_id:int, **params)->None:
        super().set_rule_params(rule_id, **params)
        
        for rule in self.rules:
            rule.set_rule_params(rule_id, **params)
            
    def add_to_igraph(self, graph:Graph=None)->Graph:
        graph = super().add_to_igraph(graph)

        for rule in self.rules:
            graph = rule.add_to_igraph(graph)
            if self._rule_id is not None and rule._rule_id is not None:
                graph.add_edge(self._rule_id, rule._rule_id)
        return graph
          
    def __rulerepr__(self)->str:
        return "CaseWhen"

class BinaryDecisionNode(BusinessRule):
    def __init__(self):
        self._store_child_params(level=2)
        
        if not hasattr(self, "default"):
            self.default = None
        if self.default is None:
            self.default = np.nan
            
        assert hasattr(self, "if_true")
        if self.if_true is None:
            self.if_true = EmptyRule()
        assert isinstance(self.if_true, BusinessRule)
        
        assert hasattr(self, "if_false")
        if self.if_false is None:
            self.if_false = EmptyRule()
        assert isinstance(self.if_false, BusinessRule)
        
        
    def predict(self, X:pd.DataFrame)->np.ndarray:
        y = np.full(len(X), np.nan)
        mask = self.__rule__(X)
        y[mask] = self.if_true.predict(X[mask])
        y[~mask] = self.if_false.predict(X[~mask])
        
        if not np.isnan(self.default):
            y = np.where(np.isnan(y), self.default, y)
            
        return y    
    
    def score_rule(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray], 
                   scores_df:pd.DataFrame=None, is_classifier:bool=False)->pd.DataFrame:
        # first predict without filling in the default
        if not np.isnan(self.default):
            old_default = self.default
            self.default = np.nan
            y_preds = self.predict(X)
            self.default = old_default 
        else:
            y_preds = self.predict(X)
            
        mask = np.invert(np.isnan(y_preds))
        scores_df = self._score_rule(y, y_preds, mask,
                                     prediction=np.nan, default=self.default, 
                                     scores_df=scores_df, is_classifier=is_classifier)
                
        rule_mask = pd.Series(self.__rule__(X)).values
        scores_df = self.if_true.score_rule(X[rule_mask], y[rule_mask], scores_df, is_classifier)
        scores_df = self.if_false.score_rule(X[~rule_mask], y[~rule_mask], scores_df, is_classifier)
        return scores_df
    
    def set_rule_id(self, rule_id:int=0)->int:
        rule_id = super().set_rule_id(rule_id)
        rule_id = self.if_true.set_rule_id(rule_id) 
        rule_id = self.if_false.set_rule_id(rule_id) 
        return rule_id
    
    def get_max_rule_id(self, max_rule_id:int=0)->int:
        max_rule_id = super().get_max_rule_id(max_rule_id)
        
        max_rule_id = self.if_true.get_max_rule_id(max_rule_id)
        max_rule_id = self.if_false.get_max_rule_id(max_rule_id)
        return max_rule_id
    
    def get_rule(self, rule_id:int)->BusinessRule:
        if self._rule_id is not None and self._rule_id == rule_id:
            return self
        
        if_true_rule = self.if_true.get_rule(rule_id)
        if if_true_rule is not None:
            return if_true_rule

        if_false_rule = self.if_false.get_rule(rule_id)
        if if_false_rule is not None:
            return if_false_rule
        
    def get_rule_input(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                      )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if y is not None:
            input_X, input_y = super().get_rule_input(rule_id, X, y)
            if input_X is not None:
                return input_X, input_y
        else:
            input_X = super().get_rule_input(rule_id, X)
            if input_X is not None:
                return input_X
            
        rule_mask = pd.Series(self.__rule__(X)).values
        

        if y is not None:
            input_X, input_y = self.if_true.get_rule_input(rule_id, X[rule_mask], y[rule_mask])
            if input_X is not None:
                return input_X, input_y
        else:
            input_X = self.if_true.get_rule_input(rule_id, X[rule_mask])
            if input_X is not None:
                return input_X
                  
        if y is not None:
            input_X, input_y = self.if_false.get_rule_input(rule_id, X[~rule_mask], y[~rule_mask])
            if input_X is not None:
                return input_X, input_y
        else:
            input_X = self.if_false.get_rule_input(rule_id, X[~rule_mask])
            if input_X is not None:
                return input_X
               
        if y is not None:
            return None, None
        else:
            return None
        
    def get_rule_leftover(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
                         )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        if self._rule_id is not None and self._rule_id == rule_id:
            y_preds = self.predict(X)
            mask = np.isnan(y_preds)
            if y is not None:
                return X[mask], y[mask]
            else:
                return X[mask]
            
        rule_mask = pd.Series(self.__rule__(X)).values
        
        if y is not None:
            leftover_X, leftover_y = self.if_true.get_rule_leftover(rule_id, X[rule_mask], y[rule_mask])
            if leftover_X is not None:
                return leftover_X, leftover_y
        else:
            leftover_X = self.if_true.get_rule_leftover(rule_id, X[rule_mask])
            if leftover_X is not None:
                return leftover_X
          
        if y is not None:
            leftover_X, leftover_y = self.if_false.get_rule_leftover(rule_id, X[~rule_mask], y[~rule_mask])
            if leftover_X is not None:
                return leftover_X, leftover_y
        else:
            leftover_X = self.if_false.get_rule_leftover(rule_id, X[~rule_mask])
            if leftover_X is not None:
                return leftover_X
               
        if y is not None:
            return None, None
        else:
            return None
        
    def replace_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        super().replace_rule(rule_id, new_rule)
        self.if_true.replace_rule(rule_id, new_rule)
        self.if_false.replace_rule(rule_id, new_rule)
       
    
    def get_rule_params(self, rule_id:int)->dict:
        params = super().get_rule_params(rule_id)
        if params is not None: 
            return params

        params = self.if_true.get_rule_params(rule_id)
        if params is not None: 
            return params

        params = self.if_false.get_rule_params(rule_id)
        if params is not None: 
            return params
            
    def set_rule_params(self, rule_id:int, **params)->None:
        super().set_rule_params(rule_id, **params)
        
        self.if_true.set_rule_params(rule_id, **params)
        self.if_false.set_rule_params(rule_id, **params)
        
    def add_to_igraph(self, graph:Graph=None)->Graph:
        graph = super().add_to_igraph(graph)
        self.if_true.add_to_igraph(graph)
        self.if_false.add_to_igraph(graph)
        
        if self._rule_id is not None and self.if_true._rule_id is not None:
            graph.add_edge(self._rule_id, self.if_true._rule_id)
        if self._rule_id is not None and self.if_false._rule_id is not None:
            graph.add_edge(self._rule_id, self.if_false._rule_id)
        return graph
              
    def __rulerepr__(self):
        return "BinaryDecisionNode"


class RuleEstimator(BusinessRule):
    def __init__(self, rules:Union[BusinessRule, List[BusinessRule]]=None,
                 final_estimator:BaseEstimator=None, fit_remaining_only:bool=True):
        super().__init__()
        if rules is None:
            print("WARNING: No rules passed! Setting a EmptyRule that predicts nan!")
            self.rules = EmptyRule()
        
        self._reset_rule_ids()
        self.fitted = False
        
    def _reset_rule_ids(self)->None:
        self.rules.set_rule_id(0)
        
    def fit(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]):
        if self.final_estimator is not None:
            print("Fitting final_estimator...")
            if self.fit_remaining_only:
                y_pred = self.rules.predict(X)
                self.final_estimator.fit(X[np.isnan(y_pred)], y[np.isnan(y_pred)])
            else:
                self.final_estimator.fit(X, y)
        self.fitted = True
        return self

    def predict(self, X:pd.DataFrame)->np.ndarray:
        assert self.final_estimator is None or self.fitted, \
            "If you have a final_estimator you need to .fit(X, y) first!"

        y = self.rules.predict(X)
         
        if self.final_estimator is not None:
            y[np.isnan(y)] = self.final_estimator.predict(X[np.isnan(y)])
        return y
    
    def get_max_rule_id(self)->int:
        return self.rules.get_max_rule_id(max_rule_id=0)
    
    def append_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        rule = self.get_rule(rule_id)
        if isinstance(rule, CaseWhen):
            rule.append_rule(new_rule)
        else:
            rule.replace_rule(rule._rule_id, CaseWhen([deepcopy(rule), new_rule]))
        self.reset_rule_ids()
        
    def replace_binarynode_true_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        binary_node = self.get_rule(rule_id)
        if isinstance(binary_node, BinaryDecisionNode):
            binary_node.if_true = new_rule
            self.reset_rule_ids()
        else:
            raise ValueError(f"rule {rule_id} is not a BinaryDecisionNode!")
        
    def replace_binarynode_false_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        binary_node = self.get_rule(rule_id)
        if isinstance(binary_node, BinaryDecisionNode):
            binary_node.if_false = new_rule
            self.reset_rule_ids()
        else:
            raise ValueError(f"rule {rule_id} is not a BinaryDecisionNode!")
        
    def score_rule(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray])->pd.DataFrame:
        return self.score_rules(X, y)
    
    def score_rules(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray])->pd.DataFrame:
        return self.rules.score_rule(X, y)
    
    def get_rule(self, rule_id:int)->BusinessRule:
        return self.rules.get_rule(rule_id)
        
    def get_rule_input(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
            )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        return self.rules.get_rule_input(rule_id, X, y)
        
    def get_rule_leftover(self, rule_id, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None
            )->Union[pd.DataFrame, Tuple[pd.DataFrame, Union[pd.Series, np.ndarray]]]:
        return self.rules.get_rule_leftover(rule_id, X, y)
    
    def replace_rule(self, rule_id:int, new_rule:BusinessRule)->None:
        self.rules.replace_rule(rule_id, new_rule)
        self._reset_rule_ids()
     
    def get_rule_params(self, rule_id:int)->dict:
        return self.rules.get_rule_params(rule_id)
        
    def set_rule_params(self, rule_id:int, **params)->None:
        self.rules.set_rule_params(rule_id, **params)
        
    def get_igraph(self)->Graph:
        self._reset_rule_ids()
        return self.rules.add_to_igraph()
    
    def plot(self):
        try:
            import plotly.graph_objects as go
        except ImportError:
            raise ImportError("Failed to load plotly, the plotting backend. "
                              "You need to install it seperately to with pip install plotly")

        graph = self.get_igraph()
        layout = graph.layout_reingold_tilford(mode="in", root=0)
        nodes_x = [6*pos[0] for pos in layout]
        nodes_y = [pos[1] for pos in layout]
        #find the max Y in order to invert the graph:
        nodes_y = [2*max(nodes_y)-y for y in nodes_y]

        connections_x, connections_y = [], []
        for edge in graph.es:
            connections_x += [nodes_x[edge.tuple[0]], nodes_x[edge.tuple[1]], None]
            connections_y += [nodes_y[edge.tuple[0]], nodes_y[edge.tuple[1]], None]


        fig = go.Figure()

        fig.add_trace(go.Scatter(
                           x=connections_x,
                           y=connections_y,
                           mode='lines',
                           name='connections',
                           line=dict(color='rgb(210,210,210)', width=1),
                           hoverinfo='none'
                           ))

        fig.add_trace(go.Scatter(
                          x=nodes_x,
                          y=nodes_y,
                          mode='markers+text',
                          name='nodes',
                          marker=dict(symbol='circle',
                                        size=18,
                                        color='#6175c1',    
                                        line=dict(color='rgb(50,50,50)', width=1)
                                        ),
                          text=[f"{id}: {desc}" for id, desc in zip(graph.vs['rule_id'], graph.vs['name'])],
                          textposition="top right",
                          hovertext=graph.vs['description'],
                          opacity=0.8
                          ))

        fig.update_layout(showlegend=False)
        fig.update_xaxes(visible=False)
        fig.update_yaxes(visible=False)
        return fig
          
    def __rulerepr__(self)->str:
        return "RuleEstimator"

    def describe(self)->str:
        description = super().describe()
        if self.final_estimator is not None:
            description += f"final_estimator = {self.final_estimator}\n"
        return description


class RuleClassifier(RuleEstimator):
    
    def score_rules(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray])->pd.DataFrame:
        return self.rules.score_rule(X, y, is_classifier=True)
    
    def suggest_rule(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray], 
                     kind='rule', after:bool=False)->BusinessRule:
        if after:
            X, y = self.get_rule_leftover(rule_id, X, y)
            if len(X) == 0:
                raise ValueError(f"No samples after application of rule {rule_id}! Try setting after=False.")
        else:
            X, y = self.get_rule_input(rule_id, X, y)
            
        dt = DecisionTreeClassifier(max_depth=1, max_features=1.0, max_leaf_nodes=2).fit(X, y)
        y_most_frequent = pd.Series(y).value_counts().index[0]
        col = X.columns.tolist()[dt.tree_.feature[0]]
        cutoff = dt.tree_.threshold[0]
        prediction = dt.classes_[dt.tree_.value[1].argmax()]
        default = dt.classes_[dt.tree_.value[2].argmax()]

        if kind=='rule':
            return f"LesserThan(col='{col}', cutoff={cutoff}, prediction={prediction}, default={default})"
        elif kind=='prediction':
            return f"PredictionRule(prediction={y_most_frequent})"
        elif kind=='node':
            return f"LesserThanNode(col='{col}', cutoff={cutoff})"

    def __rulerepr__(self)->str:
        return "RuleClassifier"

class RuleRegressor(RuleEstimator):
    
    def suggest_rule(self, rule_id:int, X:pd.DataFrame, y:Union[pd.Series, np.ndarray], 
                     kind='rule', after:bool=False)->BusinessRule:
        if after:
            X, y = self.get_rule_leftover(rule_id, X, y)
            if len(X) == 0:
                raise ValueError(f"No samples after application of rule {rule_id}! Try setting after=False.")
        else:
            X, y = self.get_rule_input(rule_id, X, y)
            
        dt = DecisionTreeRegressor(max_depth=1, max_features=1.0, max_leaf_nodes=2).fit(X, y)
        y_mean = pd.Series(y).mean()
        col = X.columns.tolist()[dt.tree_.feature[0]]
        cutoff = dt.tree_.threshold[0]
        prediction = dt.tree_.value[1].mean()
        default = dt.tree_.value[2].mean()
        
        if kind=='rule':
            return f"LesserThan(col='{col}', cutoff={cutoff}, prediction={prediction}, default={default})"
        elif kind=='prediction':
            return f"PredictionRule(prediction={y_mean})"
        elif kind=='node':
            return f"LesserThanNode(col='{col}', cutoff={cutoff})"
    
    def __rulerepr__(self)->str:
        return "RuleRegressor"