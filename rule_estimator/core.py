# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['BusinessRule', 
           'BinaryDecisionNode',
           'RuleClassifier', 
           'RuleRegressor']

from typing import Union, List, Dict
import sys
from importlib import import_module
from pathlib import Path

import numpy as np
import pandas as pd

import oyaml as yaml

from sklearn.base import BaseEstimator

def encode_storables(obj):
    """replaces all storable instances (child classes of Storable that
    have a ._stored_params attribute) in obj with a dict specifying
    module, name and params. In conjunction with decode_storables(),
    this allows instances with storable attributes to be stored to and
    loaded from yaml.

    Works recursively through sub-list and sub-dicts.
    """
    if hasattr(obj, "_stored_params"):
        return dict(__storable__=dict(
            module=obj.__class__.__module__,
            name=obj.__class__.__name__,
            params=encode_storables(obj._stored_params)))
    if isinstance(obj, dict):
        return {k:encode_storables(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [encode_storables(o) for o in obj]
    return obj


def decode_storables(obj):
    """replaces all dict-encoded storables in obj with the appropriate function

    Works recursively through sub-list and sub-dicts"""
    if isinstance(obj, dict) and '__storable__' in obj:
        obj = obj['__storable__']
        cls = getattr(import_module(obj['module']), obj['name'])
        return cls(**decode_storables(obj['params']))
    if isinstance(obj, dict):
        return {k:decode_storables(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [decode_storables(o) for o in obj]
    return obj


class Storable:

    def _store_child_params(self, level:int=1):
        """ Store parameters as attributes and to a
        self._stored_params dict.

        Args:
            level (int): level of the callstack to descend to in
                order to get the parameters. When calling this method
                in the __init__ of a child class, level=1. When called
                from the child of a child class, level=2, etc.
        """
        if not hasattr(self, '_stored_params'):
            self._stored_params = {}
        child_frame = sys._getframe(level)
        child_args = child_frame.f_code.co_varnames[1:child_frame.f_code.co_argcount]
        child_dict = {arg: child_frame.f_locals[arg] for arg in child_args}

        for name, value in child_dict.items():
            setattr(self, name, value)
            self._stored_params[name] = value

    def to_yaml(self, filepath:Union[Path, str]=None, return_dict:bool=False, comment:str=None):
        """Store object to a yaml format.

        Args:
            filepath: file where to store the .yaml file. If None then just return the
                yaml as a str.
            return_dict: instead of return a yaml str, return the raw dict.

        """
        config_dict = encode_storables(self)
        if return_dict:
            return config_dict

        comment_str = ""
        if comment is not None:
            for line in comment.splitlines():
                comment_str += "# " + line + "\n"

        yaml_str = yaml.dump(config_dict)

        if filepath is not None:
            with open(Path(filepath), "w") as f:
                f.write(comment_str + yaml_str)
        else:
            return comment_str + yaml_str
        #yaml.dump(config_dict, open(Path(filepath), "w"))

    @classmethod
    def from_yaml(cls, filepath:Union[Path, str]=None, config:Union[Dict, str]=None):
        """Instantiate object from a yaml format.

        Args:
            filepath: file where .yaml is stored.
            config: instead of filepath you can also pass a dictionary or yaml formatted
                str to config.

        """
        if config is not None:
            if isinstance(config, dict):
                config = config
            elif isinstance(config, str):
                config = yaml.safe_load(config)
            else:
                raise ValueError("config should either be a dict generated with .to_yaml(return_dict=True)"
                                " or a yaml str generated with .to_yaml()!")

        config = yaml.safe_load(open(str(Path(filepath)), "r"))
        return decode_storables(config)


def recursive_rulerepr(obj, spaces=0):
    rulerepr = ""
    if isinstance(obj, BusinessRule):
        rulerepr += " " * spaces + obj.__rulerepr__() + "\n"
    if hasattr(obj, "__dict__"):
        for k, v in obj.__dict__.items():
            if not k.startswith("_"):
                rulerepr += recursive_rulerepr(v, spaces=spaces+2)
    elif isinstance(obj, dict):
        for v in obj.values():
            rulerepr += recursive_rulerepr(v, spaces=spaces+2)
    elif isinstance(obj, list):
        for v in obj:
            rulerepr += recursive_rulerepr(v, spaces=spaces+1)
    if isinstance(obj, BusinessRule) and hasattr(obj, "default") and not np.isnan(obj.default):
        rulerepr += f"{' '*(spaces+1)}Default: {obj.default} \n"
    return rulerepr


class BusinessRule(BaseEstimator, Storable):
    def __init__(self):
        self._store_child_params(level=2)
        if (not hasattr(self, "default") or
            (hasattr(self, "default") and (self.default is None or np.isnan(self.default)))):
            self.default = np.nan

    def fit(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]=None):
        pass

    def predict(self, X:pd.DataFrame):
        raise NotImplementedError

    def get_params(self, deep=True):
        """ """
        return self._stored_params

    def set_params(self, **params):
        """ """
        self._stored_params.update(params)

    def __rulerepr__(self):
        return "BusinessRule"

    def describe(self):
        return recursive_rulerepr(self)

    def to_yaml(self, filepath:Union[Path, str]=None, return_dict:bool=False):
        """Store object to a yaml format.

        Args:
            filepath: file where to store the .yaml file. If None then just return the
                yaml as a str.
            return_dict: instead of return a yaml str, return the raw dict.

        """
        return super().to_yaml(filepath, return_dict, comment=self.describe())


class BinaryDecisionNode(BusinessRule):
    def __init__(self):
        self._store_child_params(level=2)
        assert hasattr(self, "if_true")
        assert hasattr(self, "if_false")

    def __rulerepr__(self):
        return "BinaryDecisionNode"


class RuleEstimator(BusinessRule):
    def __init__(self, rules:Union[BusinessRule, List[BusinessRule]],
                 default=None, final_estimator=None, fit_remaining_only=True):
        super().__init__()
        if not isinstance(self.rules, list):
            self.rules = [self.rules]
        self.fitted = False

    def fit(self, X:pd.DataFrame, y:Union[pd.Series, np.ndarray]):
        if self.final_estimator is not None:
            if self.fit_remaining_only:
                y_pred = self._predict_rules(X)
                X = X.copy()[np.isnan(y_pred)]
                y = y.copy()[np.isnan(y_pred)]
            print("Fitting final_estimator...")
            self.final_estimator.fit(X, y)
        self.fitted = True

    def _predict_rules(self, X:pd.DataFrame):
        y = np.full(len(X), np.nan)
        for rule in self.rules:
            y = np.where(np.isnan(y), rule.predict(X), y)

        y = np.where(np.isnan(y), self.default, y)
        return y

    def predict(self, X:pd.DataFrame):
        assert self.final_estimator is None or self.fitted, \
            "If you have a final_estimator you need to .fit(X, y) first!"

        y = self._predict_rules(X)
        if self.final_estimator is not None:
            X_remainder = X.copy()[np.isnan(y)]
            y[np.isnan(y)] = self.final_estimator.predict(X_remainder)
        return y

    def __rulerepr__(self):
        return "RulesEstimator"

    def describe(self):
        description = super().describe()
        if self.final_estimator is not None:
            description += f"final_estimator = {self.final_estimator}\n"
        return description


class RuleClassifier(RuleEstimator):

    def __rulerepr__(self):
        return "RulesClassifier"


class RuleRegressor(RuleEstimator):

    def __rulerepr__(self):
        return "RulesRegressor"